

BASES DE DATOS:
    TABLAS:
        -- Generated by the database client.
        CREATE TABLE brands(
            id SERIAL NOT NULL,
            name varchar(255) NOT NULL,
            created_at timestamp with time zone NOT NULL,
            updated_at timestamp with time zone NOT NULL,
            deleted_at timestamp with time zone,
            PRIMARY KEY(id)
        );

        -- Generated by the database client.
        CREATE TABLE inventories(
            id SERIAL NOT NULL,
            product_id integer NOT NULL,
            quantity integer DEFAULT 0,
            created_at timestamp with time zone NOT NULL,
            updated_at timestamp with time zone NOT NULL,
            deleted_at timestamp with time zone,
            PRIMARY KEY(id)
        );

        -- Generated by the database client.
        CREATE TABLE logs(
            id SERIAL NOT NULL,
            "action" varchar(255) NOT NULL,
            catalog varchar(255) NOT NULL,
            created_at timestamp with time zone NOT NULL,
            updated_at timestamp with time zone NOT NULL,
            deleted_at timestamp with time zone,
            user_id integer,
            detail_last jsonb,
            detail_new jsonb
            -- CONSTRAINT logs_user_id_fkey FOREIGN key(user_id) REFERENCES users(id)
        );

        -- Generated by the database client.
        CREATE TABLE product_sales(
            id SERIAL NOT NULL,
            product_id integer NOT NULL,
            quantity integer NOT NULL,
            total_amount integer NOT NULL,
            created_at timestamp with time zone NOT NULL,
            updated_at timestamp with time zone NOT NULL,
            deleted_at timestamp with time zone,
            PRIMARY KEY(id)
        );

        -- Generated by the database client.
        CREATE TABLE products(
            id SERIAL NOT NULL,
            name varchar(255) NOT NULL,
            "key" varchar(255) NOT NULL,
            price double precision DEFAULT 0,
            reorder_point integer DEFAULT 0,
            brand_id integer,
            supplier_id integer NOT NULL,
            created_at timestamp with time zone NOT NULL,
            updated_at timestamp with time zone NOT NULL,
            deleted_at timestamp with time zone,
            PRIMARY KEY(id)
            -- CONSTRAINT fk_brand_id FOREIGN key(brand_id) REFERENCES brands(id)
        );
        CREATE INDEX idx_products_brand_id ON "products" USING btree ("brand_id");

        -- Generated by the database client.
        CREATE TABLE suppliers(
            id SERIAL NOT NULL,
            name varchar(255) NOT NULL,
            created_at timestamp with time zone NOT NULL,
            updated_at timestamp with time zone NOT NULL,
            deleted_at timestamp with time zone,
            PRIMARY KEY(id)
        );

        -- Generated by the database client.
        CREATE TABLE users(
            id SERIAL NOT NULL,
            name varchar(255) NOT NULL,
            last_name varchar(255) NOT NULL,
            second_surname varchar(255) NOT NULL,
            email varchar(255) NOT NULL,
            password varchar(255) NOT NULL,
            created_at timestamp without time zone NOT NULL DEFAULT now(),
            updated_at timestamp without time zone NOT NULL DEFAULT now(),
            deleted_at timestamp without time zone,
            PRIMARY KEY(id)
        );

    VISTAS:
        CREATE VIEW view_users AS
        SELECT * FROM users where deleted_at is null;

        CREATE VIEW view_brands AS
        SELECT * FROM brands where deleted_at is null;

        CREATE VIEW view_products AS
        SELECT
            prds.id,
            prds.name,
            prds.key,
            prds.price,
            prds.reorder_point,
            prds.brand_id AS brand_id,
            (SELECT name FROM brands WHERE id=prds.brand_id ) AS brand_name,
            prds.supplier_id,
            (SELECT name FROM suppliers WHERE id=prds.supplier_id ) AS supplier_name,
            prds.created_at,
            prds.updated_at
        FROM products prds
        WHERE prds.deleted_at is null;


        CREATE VIEW view_products_with_inventory AS
        SELECT
            vp.id AS product_id,
            vp.supplier_id,
            vp.supplier_name,
            vp.name product_name,
            vp.key product_key,
            vp.brand_id,
            vp.brand_name,
            vp.price product_price,
            vp.reorder_point product_reorder_point,
            COALESCE(ps.quantity_sold, 0) AS quantity_sold,
            COALESCE(ip.total_quantity, 0) AS total_quantity,
            ( COALESCE(ip.total_quantity, 0)  - COALESCE(ps.quantity_sold, 0) ) AS quantity_available,
            COALESCE(ps.total_amount, 0) AS total_amount
        FROM view_products vp
        LEFT JOIN(
            SELECT product_id,SUM(quantity) total_quantity FROM inventories WHERE deleted_at IS NULL GROUP BY product_id
        ) as ip ON vp.id=ip.product_id
        LEFT JOIN (
            SELECT 
                product_id,sum(quantity) quantity_sold,sum(total_amount) total_amount 
            FROM product_sales WHERE deleted_at IS NULL GROUP BY product_id
        ) AS ps ON vp.id = ps.product_id;

        CREATE VIEW view_logs  AS
        SELECT
            lv.id id,
            lv.action,
            lv.catalog,
            lv.detail_last,
            lv.detail_new,
            u.id user_id,
            u.name user_name,
            u.last_name user_last_name,
            u.email user_email,
            lv.created_at,
            lv.updated_at
        FROM logs lv
        JOIN users u ON lv.user_id = u.id
        WHERE lv.deleted_at is null
        Order by lv.id desc;

        CREATE VIEW view_brands_with_products AS
        SELECT * FROM view_brands vb WHERE EXISTS ( SELECT 1 FROM products WHERE vb.id = products.brand_id);

        CREATE VIEW view_inventories AS
        SELECT 
            iv.id,
            vp.supplier_id,
            (SELECT name FROM suppliers WHERE id=vp.supplier_id) AS supplier_name,
            iv.product_id,
            vp.name,
            vp.key,
            vp.brand_name,
            iv.quantity,
            vp.price,
            vp.reorder_point,
            iv.created_at,
            iv.updated_at
        FROM inventories iv    
            INNER JOIN view_products vp ON iv.product_id=vp.id
        WHERE iv.deleted_at is null;

        CREATE VIEW view_product_sales AS
        SELECT 
            ps.id,
            ps.product_id,
            vp.name,
            vp.key,
            vp.brand_name,
            ps.quantity AS quantity_sold,
            ps.total_amount,
            ps.created_at,
            ps.updated_at
        FROM product_sales ps  
            INNER JOIN view_products vp ON ps.product_id=vp.id
        WHERE ps.deleted_at is null;

        CREATE VIEW view_suppliers AS
        SELECT * FROM suppliers where deleted_at is null;


    FUNCIONES/PROCEDIMIENTOS:
        CREATE OR REPLACE FUNCTION public.create_log(p_user_id integer, p_action character varying, p_catalog character varying, p_detail_last jsonb, p_detail_new jsonb)
        RETURNS void
        LANGUAGE plpgsql
        AS $function$
        BEGIN
            INSERT INTO logs (user_id, action, catalog, detail_last, detail_new, created_at,updated_at)
            VALUES (p_user_id, p_action, p_catalog, p_detail_last, p_detail_new, NOW(),NOW());
        END;
        $function$

    CONSULTAS:
        -- Estadisticas de los producvtos vendidos de cada proveedor
        SELECT 
            vs.id,
            vs.name,
            vp.num_products,
            vp.quantity_sold,
            vp.total_quantity,
            vp.quantity_available
        FROM view_suppliers vs
        LEFT JOIN(
            SELECT 
                supplier_id,
                COUNT(*) num_products,
                SUM(quantity_sold) quantity_sold,
                SUM(total_quantity) total_quantity,
                SUM(quantity_available) quantity_available
            FROM  view_products_with_inventory 
            GROUP BY supplier_id
        ) vp ON vs.id=vp.supplier_id;
    * COMANDOS PARA RECORDAR
        TRUNCATE products;
        SELECT setval('products_id_seq', 1, false);

        DELETE FROM brands;
        SELECT setval('brands_id_seq', 1, false);

        DELETE FROM logs;
        SELECT setval('logs_id_seq', 1, false);
        SELECT * FROM pg_views where Schemaname='public';
        select pg_get_viewdef('view_all_logs', true);
        SELECT nextval('products_id_seq') AS proximo_id;

## Cambios de nomenclaturas
    **camelCase** = funcionADeclarar
    **snake_case**  = variable_a_declarar
    **PascalCase**  = ClaseADeclarar
    **kebab-case** = archivo-a-declarar
## Campo delted_at


* CONSIDERACIONES
    Usar vistas en todas las consultas a excepcion de las actualizaciones,eliminacione sy creaciones
    Corregir nomenclaturas
    Limpiar y reiniciar tablas
    Validaciones de minimo y maximo en el nombre de las marcas
    Validacion de nombres unicos en marcas
endpoint que me den las marcas que tienen productos
original y cambio en log
No permitir actualizar nombres de marcas que ya existan

Corregir:
    Permitir selecionar created_at and updated_at
    Crear un procedimiento almacenado que reciba los logs y los guarde
    paginacion de pg_ls_archive_statusdir



NUEVOS REQUERIMIENTOS:
    Se necesita que los productos permitan saber cuando se compra del producto y cuanto.
    Que cuando me compren ese producto igual se guarde y cuanto.
    Cundo yo compre quiero saber de que proveedor es.
    Cuado me compren el producto y yo ya llegue a mi punto de reorden que me alerte que ya hay que comprar mas.
    Punto de reorden: Cuando solo se tengan solo 10 unidades

    Que hacer:
        Rutas:
            sale/product_sale
                body:
                    id_product
                    quantity
                Proceso:
                    Recibir los parámetros
                        validar si la cantidad de productos a comprar esta disponible (Transaciones)
                            Guardar la venta en a tabla de product_sales
                                * Obtener el precio total, multiplicando las unidades por el precio de cada unidad
                            Si la venta se gaurdo disminuir la cantidad de productos del producto buscandolo por el id
                        Si la cantidad no esta disponible indicarlo al usuario
                            Mensaje informativo
                        Informar si la cantidad disminuida del usuario es menor o igual a su punto de reorden
                            Si esto se cumple indicarlo en la respuesta
            sale/find_all
                Obtener todas las ventas
            Inventarios/(CRUD)
                Considerar los nuevos campos en las rutas (id_supplier,quantity,price,reorder_point)
            supplier/(CRUD)
                Considerar crear una tabla de proveedores

            product/ (Edit/Crear/Obtener)
                Considerar los nuevos campos en las rutas (id_supplier,quantity,price,reorder_point)
            
        reports
            product/report_resume: Select * from view_products_with_inventory


        Tablas/ Ajustes:
            product_sales
                product_id not null
                quantity 
                total_amount
                created_at
                updated_at
                deleted_at
                * No restaurar
            
            inventories
                product_id not null
                quantity default 0
                reorder_point default 0
            
            suppliers
                id
                name
                updated_at
                deleted_at
            products
                name
                key
                * price
                * reorder_point
                * supplier_id
        corregir
            * a la hora de gurdar la venta y el punto de reorden tomar la dispobnibilidad desde la vista construida de productos    
            * Vista de productos todas sus ventas, todas sus compras, cantidad disponible














































































MYSQL:
-- Tabla de marcas
CREATE TABLE brands (
    id INT AUTO_INCREMENT NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    deleted_at TIMESTAMP,
    PRIMARY KEY (id)
);
-- Tabla de productos
CREATE TABLE products (
    id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
    name VARCHAR(255) NOT NULL,
    `key` VARCHAR(255) NOT NULL,
    brand_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,
    FOREIGN KEY (brand_id) REFERENCES brands (id)
);

-- Tabla de proveedores
CREATE TABLE suppliers (
    id INT AUTO_INCREMENT NOT NULL,
    name VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    deleted_at TIMESTAMP,
    PRIMARY KEY (id)
);

-- Tabla de usuarios
CREATE TABLE users (
    id INT AUTO_INCREMENT NOT NULL,
    name VARCHAR(255) NOT NULL,
    last_name VARCHAR(255) NOT NULL,
    second_surname VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password VARCHAR(255) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    deleted_at TIMESTAMP,
    PRIMARY KEY (id)
);


-- Tabla de inventarios
CREATE TABLE inventories (
    id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
    product_id INT NOT NULL,
    supplier_id INT NOT NULL,
    quantity INT DEFAULT 0,
    reorder_point INT DEFAULT 0,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    deleted_at TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(id),
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);

-- Tabla de logs
CREATE TABLE logs (
    id INT  PRIMARY KEY AUTO_INCREMENT NOT NULL,
    action VARCHAR(255) NOT NULL,
    catalog VARCHAR(255) NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    deleted_at TIMESTAMP,
    user_id INT,
    detail_last VARCHAR(255)  NULL,
    detail_new VARCHAR(255)  NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Tabla de ventas de productos
CREATE TABLE product_sales (
    id INT PRIMARY KEY AUTO_INCREMENT NOT NULL,
    product_id INT NOT NULL,
    quantity INT NOT NULL,
    total_amount INT NOT NULL,
    created_at TIMESTAMP NOT NULL,
    updated_at TIMESTAMP NOT NULL,
    deleted_at TIMESTAMP,
    FOREIGN KEY (product_id) REFERENCES products(id)
);


